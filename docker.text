도커가 없던 세상 : 

  서버: 작성된 코드를 실제로 서비스하는 컴퓨터

  서비스를 운영할때 필요한 서버 운영작업
    : 1. 보안 결함이 없어야 한다.
      2. 필요할 때 새로운 코드나, 라이브러리 추가가 가능해야 한다.
      
    요청이 많이 들어올 수록 많은 서버가 필요하다 (부하 분산 최소2대)  
    
    서버가 증설되면 다양한 요청이 들어올 수 있음 
    
    보안을 강화한다던가,
    서버를 바꾼다던가 (ubuntu에서 centos로),
    python 3.8 -> 3.9 업데이트,
    이번 서비스는 JAVA(...)로 만들고 싶어요! 라던가하는 
    
    서비스가 커지고 서버가 늘어나면 -> 원하는대로 application을 실행하는것도 어려워짐 
    
    why? -> 각 상황에 따라 스크립트를 작성하고 모든 서버에서 원하는 상태를 만들어 줘야 하기 때문
        -> 이슈가 생겼을때 떠 빠르게 해결할 수 있다.

  도커가 없던 세상 : 원하는 프로그램을 실행하는게 어려웠다!    


  도커가 문제를 해결한 방법 :

    - 문제 정의) 원하는 프로그램을 실행하는 게 어렵다!
    - 서비스를 운영하기 위해서 단순히 코드를 짜는 것뿐만 아니라 서버도 운영을 해주어야 한다. 
      그런데 서버를 운영하는건 점점 복잡해진다.

- 해결 방안) 서버 운영에서 인프라 관리와 어플리케이션 작성을 분리하면 어떨까?
    - 실행환경, 실행하는 코드, 필요한 라이브러리, 설정 파일을 한곳에 정의해두면 어떨까? ⇒ **도커 이미지**
    - 서버에서는 간단하게 이미지를 가지고 실행만 시키자!

- 이런 패러다임을 적용시키기 위해서 해결해야 할 3가지 문제
    1. 이미지를 생성하는 법
        👉 일관성 있게 이미지를 만들 수 있고, 어플리케이션을 실행하는 데 필요한 모든 것을 설정할 수 있는 이미지
        
    2. 이미지를 공유하는 법
        👉 이미지가 어디에서든 잘 전달할 수 있게 만들어 필요한 곳에서 사용할 수 있게 한다.
        
    3. 이미지를 실행하는 법
        👉 일관성있게 이미지를 실행할 수 있다.
        

So  what is the Docker? : 원하는 프로그램을 쉽게 실행하기 위한 플랫폼


도커의 구성 요소 

image : application을 실행하기 위해 필요한 것들이 저장되어 있는 파일 
container : image를 실행한 것
            독립성을 보장하기 위해 네트워크와 저장소가 분리되어 있다.
Docker registry : docker image를 저장하는 공간
docker daemon : image를 registry에서 다운/업로드, image에서 container를 실행하거나, image를 새로 만들거나 하는 
                docker object(image, container, 볼륨, 네트워크등)을 관리하는 프로그램 

client, docker build, docker pull, docker run : docker daemon한테 일시키는 주체?
-> 도커 이미지를 만들거나, 이미지를 레지스트리에서 다운 받거나, 이미지에서 container를 만드는 명령
-> Client, Docker cli환경에서 직접 dockr daemon한테 요청할 수 있음


예전에도 가상머신이라는 비슷한 기술이 있었음 
-> 서버에 os 설치 후 하이퍼바이저 설치
-> 그 위에서 원하는 os설치
-> 그 위에 라이브러리나 바이너리 설치
-> 앱 코드를 받아서 실행
-> 여러개의 앱을 생성하려면 여러개의 os를 생성해야되는 환경

가상머신의 불편한점
-> 필요한 운영체제를 하이퍼바이저위에 올렸는데, 이러면 새로운 디스크를 할당받거나, 인터넷 통신등을 할때 
   하이퍼바이저를 거쳐야 하므로 대부분의 성능이 hostos에서 직접하는 것보다 많이 떨어짐
-> os세팅이 항상 필요(최소 몇기가에서 몇십기가 )  -> 코드 세팅이 엄청 커짐

도커는 리눅스의 chroot, cgruop, namespace와 같이 리소스를 분리하여 각각의 독립성을 보장하여 좀더 일관된 형태로 쓰기 쉽게 만들어 놓음
-> 성능저하가 없음
-> 이미지의 크기도 작아집(몇 십 메가바이트)


docker run --help : 옵션 설명서

docker run -d -p 80:80 docker/getting-started
-d -> detach option -
-> process container를 백그라운드로 실행하겠다는 의미

-p -> publish
docker/getting-started 라는 application이 웹 서비스이니
80번 포트로 서비스 제공
-> 그런데 거글 localhost에서도 접속을 해야 되니 두개를 연결해주겠다
80(호스트 포트) : 80(컨테이너 내부에서 서빙하는 포트)


도커 멈추는 커멘드
docker stop {container_id|conatinaer_name} -> 프로세서 종료(어플리케이션 종료시 정리 할 시간을 보장해줌)
docker kill {container_id|conatinaer_name} -> 프로세서 삭제 (얄짤없음)

컨테이너 상태보기
sudo docker ps -a -> 멈춘 것도 보여줌
sudo docker ps  -> 실행중인 도커 상태 보여줌

sudo docker exec [options] {container_id|container_name} [command]


