도커가 없던 세상 : 

  서버: 작성된 코드를 실제로 서비스하는 컴퓨터

  서비스를 운영할때 필요한 서버 운영작업
    : 1. 보안 결함이 없어야 한다.
      2. 필요할 때 새로운 코드나, 라이브러리 추가가 가능해야 한다.
      
    요청이 많이 들어올 수록 많은 서버가 필요하다 (부하 분산 최소2대)  
    
    서버가 증설되면 다양한 요청이 들어올 수 있음 
    
    보안을 강화한다던가,
    서버를 바꾼다던가 (ubuntu에서 centos로),
    python 3.8 -> 3.9 업데이트,
    이번 서비스는 JAVA(...)로 만들고 싶어요! 라던가하는 
    
    서비스가 커지고 서버가 늘어나면 -> 원하는대로 application을 실행하는것도 어려워짐 
    
    why? -> 각 상황에 따라 스크립트를 작성하고 모든 서버에서 원하는 상태를 만들어 줘야 하기 때문
        -> 이슈가 생겼을때 떠 빠르게 해결할 수 있다.

  도커가 없던 세상 : 원하는 프로그램을 실행하는게 어려웠다!    


  도커가 문제를 해결한 방법 :

    - 문제 정의) 원하는 프로그램을 실행하는 게 어렵다!
    - 서비스를 운영하기 위해서 단순히 코드를 짜는 것뿐만 아니라 서버도 운영을 해주어야 한다. 
      그런데 서버를 운영하는건 점점 복잡해진다.

- 해결 방안) 서버 운영에서 인프라 관리와 어플리케이션 작성을 분리하면 어떨까?
    - 실행환경, 실행하는 코드, 필요한 라이브러리, 설정 파일을 한곳에 정의해두면 어떨까? ⇒ **도커 이미지**
    - 서버에서는 간단하게 이미지를 가지고 실행만 시키자!

- 이런 패러다임을 적용시키기 위해서 해결해야 할 3가지 문제
    1. 이미지를 생성하는 법
        👉 일관성 있게 이미지를 만들 수 있고, 어플리케이션을 실행하는 데 필요한 모든 것을 설정할 수 있는 이미지
        
    2. 이미지를 공유하는 법
        👉 이미지가 어디에서든 잘 전달할 수 있게 만들어 필요한 곳에서 사용할 수 있게 한다.
        
    3. 이미지를 실행하는 법
        👉 일관성있게 이미지를 실행할 수 있다.
        

So  what is the Docker? : 원하는 프로그램을 쉽게 실행하기 위한 플랫폼


도커의 구성 요소 

image : application을 실행하기 위해 필요한 것들이 저장되어 있는 파일 
container : image를 실행한 것
            독립성을 보장하기 위해 네트워크와 저장소가 분리되어 있다.
Docker registry : docker image를 저장하는 공간
docker daemon : image를 registry에서 다운/업로드, image에서 container를 실행하거나, image를 새로 만들거나 하는 
                docker object(image, container, 볼륨, 네트워크등)을 관리하는 프로그램 

client, docker build, docker pull, docker run : docker daemon한테 일시키는 주체?
-> 도커 이미지를 만들거나, 이미지를 레지스트리에서 다운 받거나, 이미지에서 container를 만드는 명령
-> Client, Docker cli환경에서 직접 dockr daemon한테 요청할 수 있음


예전에도 가상머신이라는 비슷한 기술이 있었음 
-> 서버에 os 설치 후 하이퍼바이저 설치
-> 그 위에서 원하는 os설치
-> 그 위에 라이브러리나 바이너리 설치
-> 앱 코드를 받아서 실행
-> 여러개의 앱을 생성하려면 여러개의 os를 생성해야되는 환경

가상머신의 불편한점
-> 필요한 운영체제를 하이퍼바이저위에 올렸는데, 이러면 새로운 디스크를 할당받거나, 인터넷 통신등을 할때 
   하이퍼바이저를 거쳐야 하므로 대부분의 성능이 hostos에서 직접하는 것보다 많이 떨어짐
-> os세팅이 항상 필요(최소 몇기가에서 몇십기가 )  -> 코드 세팅이 엄청 커짐

도커는 리눅스의 chroot, cgruop, namespace와 같이 리소스를 분리하여 각각의 독립성을 보장하여 좀더 일관된 형태로 쓰기 쉽게 만들어 놓음
-> 성능저하가 없음
-> 이미지의 크기도 작아집(몇 십 메가바이트)


docker run --help : 옵션 설명서

docker run -d -p 80:80 docker/getting-started
-d -> detach option -
-> process container를 백그라운드로 실행하겠다는 의미

-p -> publish
docker/getting-started 라는 application이 웹 서비스이니
80번 포트로 서비스 제공
-> 그런데 거글 localhost에서도 접속을 해야 되니 두개를 연결해주겠다
80(호스트 포트) : 80(컨테이너 내부에서 서빙하는 포트)


도커 멈추는 커멘드
docker stop {container_id|conatinaer_name} -> 프로세서 종료(어플리케이션 종료시 정리 할 시간을 보장해줌)
docker kill {container_id|conatinaer_name} -> 프로세서 삭제 (얄짤없음)

컨테이너 상태보기
sudo docker ps -a -> 멈춘 것도 보여줌
sudo docker ps  -> 실행중인 도커 상태 보여줌

sudo docker exec [options] {container_id|container_name} [command]
-> 어떤 container에 어떤 command를 날릴건지 

sudo docker exec -ti {container_id|container_name} sh
-> 도커 쉘 진입

docker exec -i : interactive 옵션 쉘 스크립트로 쓸때 따로 받지않고 localhost에서 친걸
                  container에서도 쓰겠다.

            -t : -tty옵션. 터미널 환경을 만들어서 쉘 스크립트를 만들때 사용할

도커 삭제
sudo docker rm container_id

더 많은 명령어
https://docs.docker.com/engine/reference/commandline/cli/

도커 이미지 만들기 위해 -> 도커 파일 필요

FROM python:3.9 -> 이미지를 만들때 어떤 이미지부터 생성할지 결정 여기선 파이선3.9가 실행할 수 있는 환경이 세팅되어저 있는 이미지를 사용해서 docker이미지를 만들겠음!

ADD requirements.txt . -> 호스트 머신에 있는 파일을 도커 이미지를 '.' 위치에  넣겠음

RUN pip install - r requirements.txt -> 쉘에서 run 커멘드를 실행해서 환경을 만들겠뜸!

ADD app.py . -> 호스트 머신에 있는 파일을 도커 이미지를 '.' 위치에  넣겠음

ADD templates ./templates/ -> 호스트 머신에 있는 폴더를 .//폴더로 옮기겠음!

CMD ["python", "app.py"] -> 이미지에 어떤 명령어가 기본으로 실행될 것인지 정의, 커멘드가 없이 실행되면 python app.py가 실행됨





도커이미지를 만들때는 
베이스 이미지에서 시작해서 각각의 명령어가 하나씩 실행될때마다
레이어가 하나씩 생기게 되고

레이어가 동일한 환경에서 빌드를 하게 되었을 때
동일한 커맨드로 빌드를 하게 된다고 하면
빌드된 것은 이전 빌드된 결과물을 사용하기 때문에 
8초가 아니라 0.1초가 걸린것 (말을 거창하게 늘리네 ㄷㄷ )


도커 이미지는 레이어라는 개념이 존재한다


도커 이미지는 레포지토리와 태그의 조합으로 생성되어 한번 정해지면 바뀌지 않는다
-> 보통 이미지를 측정할 때 레포지토리와 테그로 특정을 짓는데 
-> 이게 바뀌면 똑같은 이미지, 레포지토리를 실행했을 때, 
-> 정상일수도 비정상일수도 있음(복불복)
-> 물론 태그가 같더라도 바뀌는건 일반적일 수도 있음
-> 파이썬 빌드 업데이튼같은 경우
-> 하지만 일반적으로는 태그의 조합이 변하지 않는다

